#* String i şu şekilde terse çeviriyoruz, iki yöntem de olur

	original_string = "Hello, World!"
    reversed_string = original_string[::-1]
    reversed_string = ''.join(reversed(original_string))
	
	#-1 yerine -2 ya da 2 vs kullanınca her 2 karakterde birini basıyor, "Hlo Wrd" gibi

s = "abcdefgh"

# Slicing with start, end, and step values
sliced1 = s[1:6:2]  # Output: "bdf"
sliced2 = s[::3]    # Output: "adg"
sliced3 = s[:4]     # Output: "abcd"
sliced4 = s[2:]     # Output: "cdefgh"    


#* Kalan işlemi şu şekilde
  remainder = 123 % 10 # sonuç 3

#* Aşağıya yuvarlama:
  round_down = 17 // 5 # sonuç 3

#* 
  for i in range(5) # 0 1 2 3 4
  for i in range (5,-1,-1) # 5 4 3 2 1 0

#* 
    s = 'deneme'
    print(s[1:3]) # en  

#*
    import re
    s = re.sub(r'[^a-z0-9]', '', s)  #  The expression [^a-z0-9] matches any character that is not a lowercase letter or a digit.  
    # The r before the pattern string indicates a "raw string," which is used to treat the backslashes (\) as literal characters rather than escape characters.
    print(re.sub(r'[.]', '[.]', "111.000.255")) # "111[.]000[.]255" döndürüyor, soru zaten bunu istiyordu.
    
#* 
  ord(character) - 64# 'A' için 1, B için 2 verir ama küçük harf için 64 olmaz. Daha güzeli
  ord(character) - ord('A') + 1 # istersen ord('a') yaparsın. 
  chr(ord('a')) # bu ekrana 'a' basar, loop içinde chr(ord('a') + i) diye dönerek, tüm alfabeyi bir listeye aldırabilirsin ya da dictionary key yapabilirsin.

#* 
  s = "deneme"
  s.index("e") # 1 basar çünkü ilk e harfi 1. indexde
  s.index("e",2) # 3 basar çünkü 2. indexten sonraki ilk e harfi 3. index te
  for idx in s:
    print(s.index(idx)) #0 1 2 1 4 3 basıyor.
  # 205. Isomorphic Strings sorusunda kullanılıyor. Kelime içinde her harfe unique sayı atamayı sağlıyor. e harfi 10 kere de bulunsa, ilk e harfinin değerini hashmap(dictionary) e atıyorsun.
  
#* 
    my_dict = {"a": 1, "b": 2, "c": 3}

    if "d" not in my_dict:
        print("'d' is not a key in the dictionary.")
    else:
        print("'d' is a key in the dictionary.")

#* Return etmen gereken şey string ise ve bu stringi loop içinde karakter by karakter dolduruyorsan şunu yaparsın
str = []
str.append('a')
str.append(source[i])

return ''.join(str)

# 1678. Goal Parser Interpretation sorusunu tek satırda şöyle çözmüşler:
return command.replace('()','o').replace('(al)','al')

#*   
    str = "deneme"
    str[0] = 'f'
    print(str[0])
    # this gives error because Strings in Python are immutable, meaning you cannot modify individual characters in-place.
    modified_str = list(str) # bunu yaptıktan sonra artık modified_str[0] = 'm' vs yapabilirsin.
    #En sonda string return edeceksen de şöyle oluyor:
    return ''.join(modified_str)

# List comprehension diye bir olay var, şu syntax ile çalışıyor:

numbers = [1, 2, 3, 4, 5]
squares = [x ** 2 for x in numbers]
# Result: [1, 4, 9, 16, 25]

numbers = [1, 2, 3, 4, 5]
even_numbers = [x for x in numbers if x % 2 == 0]
# Result: [2, 4]

text = "Hello, World!"
uppercase_letters = [char for char in text if char.isupper()]
# Result: ['H', 'W']

numbers = [1, 2, 3, 4, 5]
result = ["even" if num % 2 == 0 else "odd" for num in numbers]
# Result: ['odd', 'even', 'odd', 'even', 'odd']

names = ["Alice", "Bob", "Charlie"]
name_lengths = {name: len(name) for name in names}
# Result: {'Alice': 5, 'Bob': 3, 'Charlie': 7}  

# List i alıyor, dictionary yapıyor ya da hashset  

nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for sublist in nested_list for num in sublist]
# Result: [1, 2, 3, 4, 5, 6, 7, 8, 9]

# Sanki içiçe 2 loop  yapıyor ve değerini bir liste olarak yazdırıyor.
# Burda kilit olan "for i in some_list" kısmı, sonrası akla gelir


#* 
  ret.append(char_map.get(chr, chr)) 
# Burda şunu yapıyo, char_map dictionary de eğer aradığı key i bulamazsa, aradığı değeri aynen append ediyor. nvl() gibi sql deki

* # dict, chr gibi built-in isimleri kullanma 

* if rev[i] in '123456789':  # Karakter bir sayı mı bu şekilde bakılabilir.

*   lst = []
    lst.append('d')
    lst.append('e')
    lst.append('l')
    lst[-1] += 'a'
    print((lst[-1])[::-1])
    # lst += 'a' yapsaydık, yeni bir node açıp 'a'  yı eklerdi. Bu şekilde en son nodu 'la'  yaptı. print içindeki yapı da ilginç, o nodu array gibi gösterip terse çevirebiliyoruz.

* # Eğer bir listeden sayıları string olarak okuduysan, onu başka listede indice olarak kullanamazsın, int() ile cast etmen lazım.
  # Aynı şekilde mesela print("test:" + 8) deyince de hata veriyor, onu da print(f"test: {8}") diye formatlayabilirsin veya "str(8)" deyip cast edebilirsin.

* # Başta dictionary tanımlayıp,mesela key integer olsun, value da list of string olsun dersen şu örnekteki gibi yapmalısın:

    number_groups = {}

    # Sample list of strings
    strings = ["apple", "banana", "cherry", "date", "elephant", "fig"]

    # Group words by their lengths
    for word in strings:
        length = len(word)
        if length in number_groups:
            number_groups[length].append(word)
        else:
            number_groups[length] = [word]

    # Print the dictionary
    for length, words in number_groups.items():
        print(f"Words with length {length}: {words}")

    '''
    Words with length 5: ['apple', 'cherry']
    Words with length 6: ['banana']
    Words with length 4: ['date']
    Words with length 8: ['elephant']
    Words with length 3: ['fig']
    '''
    
# Dictionary de key ve value ye nasıl ulaşılır?
    my_dict = {"a": 1, "b": 2, "c": 3}

    for key in my_dict:
        print(key)

    for keys in my_dict.keys():
        print(keys)

    for vals in my_dict.values():
        print(vals)

    for key, value in my_dict.items():
        print(key)
        print(value)
        print(key + str(value))    

 #49. Group Anagrams sorusunun aşağıdaki kodu çok güzel:
  # sorted() fonksiyonu içine "word" variable string olarak giriyor ama bu fonksiyon onu list of characters yapıyor. Bu yüzden "join" ile tekrar string yaptı
  # anagram_dict[word_key] = [word] kullanımında "[word]" yapmasının nedeni value nun list data type olmasını sağlamak, yoksa direkt "word" olsa o zaman üstteki append hata veriyor
  # çünkü append string te çalışmıyor, list data type ta çalışıyor.
  # return ederkenki ifade de cast açısından güzel.

    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        #Input: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
        #Output: [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]]

        anagram_dict = {}

        for word in strs:
            word_key = ''.join(sorted(word))

            if word_key in anagram_dict:
                anagram_dict[word_key].append(word)
            else:
                anagram_dict[word_key] = [word]

        return list(anagram_dict.values())    


#*
 str = str_array[0] + str_array[1] #Bu şekilde character toplamı ile string elde edebilirsin.        
        
        
        
        
* #1910. Remove All Occurrences of a Substring
    s_new = s

    while part in s_new:
        s_new = s_new[0:s_new.index(part)] + s_new[s_new.index(part)+len(part) : len(s_new)]
    
    return s_new
    
    #Bu kodda index kullanımı güzel

* # bu [i:j] meselesini aşağıdaki örnekle anlıyorsun iyice. İndisleme aslında soldan sağa 0,1,2..  sağdan,sola -1,-2,-3.. diye yapılıyor.
  # ilk 2 sonucun aynı olması bu mantıktan.
    s = "denemelik"
    print(s[:-3]) #deneme
    print(s[:6])  #deneme
    print(s[:3])  #den
    print(s[-3:]) #lik
    print(s[3:])  #emelik  

            